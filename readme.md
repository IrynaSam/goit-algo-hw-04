# Аналіз ефективності алгоритмів сортування

## Досліджено ефективність трьох алгоритмів:

- Сортування злиттям (**Merge Sort**)
- Сортування вставками (**Insertion Sort**)
- Вбудований **Timsort** (`sorted()` і `list.sort()` у Python)

Тестування проведено на масивах випадкових чисел розміром **1000**, **5000** та **10000** елементів.

---

## Результати тестування

### Час виконання (у секундах):

| Розмір списку | Merge Sort | Insertion Sort | Timsort `sorted()` | Timsort `sort()` |
| ------------- | ---------- | -------------- | ------------------ | ---------------- |
| 1000          | 0.003676   | 0.041224       | 0.000120           | 0.000110         |
| 5000          | 0.022678   | 1.083854       | 0.000667           | 0.000609         |
| 10000         | 0.046310   | 5.194945       | 0.001682           | 0.001541         |

---

## Висновки

- **Insertion Sort** має найгіршу продуктивність при зростанні розміру масиву. Його час виконання збільшується експоненційно, що підтверджує складність **O(n²)**. При 10 000 елементах він працює у понад **5000 разів повільніше**, ніж Timsort.
- **Merge Sort** показує хорошу стабільну продуктивність. Зростання часу відповідає складності **O(n log n)**.
- **Timsort** (`sorted()`, `.sort()`) є **найефективнішим**: швидкість виконання значно краща за інші алгоритми навіть на великих масивах. Він також адаптивний до вже частково відсортованих масивів.

---

## Практичний висновок

Python використовує **Timsort** у вбудованих функціях сортування (`sorted()`, `.sort()`) завдяки його:

- адаптивності
- стабільності
- високій продуктивності

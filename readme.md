Аналіз ефективності алгоритмів сортування
Досліджено ефективність трьох алгоритмів сортування:

Сортування злиттям (Merge Sort)
Сортування вставками (Insertion Sort)
Вбудований Timsort (sorted і sort у Python)
Тестування проведено на масивах випадкових чисел розміром 1000, 5000 та 10000 елементів.

Результати тестування
Розмір списку: 1000 елементів Сортування злиттям (Merge Sort): 0.003648 sec Сортування вставками (Insertion Sort): 0.040681 sec Вбудований Timsort (sorted): 0.000133 sec Вбудований Timsort (sort): 0.000121 sec

Розмір списку: 5000 елементів Сортування злиттям (Merge Sort): 0.022883 sec Сортування вставками (Insertion Sort): 1.119787 sec Вбудований Timsort (sorted): 0.000778 sec Вбудований Timsort (sort): 0.000744 sec

Розмір списку: 10000 елементів Сортування злиттям (Merge Sort): 0.049229 sec Сортування вставками (Insertion Sort): 4.510963 sec Вбудований Timsort (sorted): 0.001752 sec Вбудований Timsort (sort): 0.001624 sec

Розмір списку Merge Sort (сек) Insertion Sort (сек) Timsort sorted() (сек) Timsort sort() (сек)
1000 0.003648 0.040681 0.000133 0.000121
5000 0.022883 1.119787 0.000778 0.000744
10000 0.049229 4.510963 0.001752 0.001624
Висновки
Сортування вставками (Insertion Sort) найгірше підходить для великих даних. Його час виконання зростає експоненційно, що підтверджує його часову складність O(n²). При 10 000 елементах воно працює у 2500 разів повільніше, ніж Timsort.

Сортування злиттям (Merge Sort) показує стабільні результати. Час виконання зростає приблизно лінійно відносно розміру масиву, що узгоджується з теоретичною оцінкою O(n log n).

Вбудований Timsort (sorted і sort) є найефективнішим варіантом. Його виконання у сотні разів швидше, ніж Merge Sort, і у тисячі разів швидше, ніж Insertion Sort. Це підтверджує його адаптивність та ефективність для реальних даних.

Висновок для практичного застосування
Python використовує Timsort у своїх вбудованих функціях сортування (sorted() і list.sort()) саме через його адаптивність і високу ефективність. У більшості випадків не варто реалізовувати власні алгоритми сортування, оскільки вбудовані рішення вже оптимізовані для швидкості та ефективності.
